//cloudinary.constants.js:
import { v2 as cloudinary } from 'cloudinary';
import dotenv from 'dotenv/config';

cloudinary.config({
    cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
    api_key: process.env.CLOUDINARY_API_KEY,
    api_secret: process.env.CLOUDINARY_API_SECRET,
});

export default cloudinary;

//category.controller.js
import CategoryValidateSchema from "../validators/Category.validator.js";
import Category from "../models/Category.model.js";
import asyncWrapper from "../utils/asyncWrapper.utils.js";
import uploadToCloudinary from '../utils/cloudinary.utils.js';
import saveImageLocally from '../utils/saveLocally.utils.js';
import cloudinary from '../constants/cloudinary.constant.js';
import ApiError from "../utils/apiError.utils.js";

const createCategory = asyncWrapper(async (req, res) => {
  await CategoryValidateSchema.validate(req.body);

  const categoryExists = await Category.findOne({ categoryName: req.body.categoryName });
  if (categoryExists) {
    throw new ApiError(400, 'Category already exists');
  }
  
  if (!req.file) {
    throw new ApiError(400, 'Category image is required');
  }

  if(req.file.size > 1024 * 500){
    throw new ApiError(400, 'Category image size should be less than 500KB');
  }

  let imageUrl = '';
  let cloudinaryId = '';

  if (req.file) {
    try {
      const result = await uploadToCloudinary(req.file);
      console.log(result);
      imageUrl = result.secure_url;
      cloudinaryId = result.public_id;
      console.log(cloudinaryId, imageUrl);
    } catch (err) {
      console.error('Cloudinary failed:', err.message);
      imageUrl = saveImageLocally(req.file); 
    }
  }

  const createdCategory = await Category.create({
    categoryName: req.body.categoryName,
    slug: req.body.slug,
    categoryDescription: req.body.categoryDescription,
    categoryImage: imageUrl,
    cloudinaryId: cloudinaryId,
  });

  return res.status(201).json({
    message: `Created Successfully`,
    category: createdCategory,
  });

});

const updateCategory = asyncWrapper(async (req, res) => {
  const categoryId = req.params.categoryId;
  const category = await Category.findById(categoryId);
  if (!category) return res.status(404).json({ message: 'Category not found' });

  let updatedFields = req.body;

  if (req.file) {
    try {
      if (category.cloudinaryId) {
        await cloudinary.uploader.destroy(category.cloudinaryId); // delete old image
      }
      const result = await uploadToCloudinary(req.file);
      updatedFields.imageUrl = result.secure_url;
      updatedFields.cloudinaryId = result.public_id;
    } catch (err) {
      console.error('Cloudinary failed:', err.message);
      updatedFields.imageUrl = saveImageLocally(req.file); // fallback
    }
  }

  const updatedCategory = await Category.findByIdAndUpdate(categoryId, updatedFields, { new: true });

  return res.status(200).json({
    message: `Updated ${updatedCategory.categoryName} Successfully`,
    category: updatedCategory,
  });
});

const deleteCategory = asyncWrapper(async (req, res) => {
  const categoryId = req.params.categoryId;
  const category = await Category.findById(categoryId);
  if (!category) return res.status(404).json({ message: 'Category not found' });

  if (category.cloudinaryId) {
    try {
      await cloudinary.uploader.destroy(category.cloudinaryId);
    } catch (err) {
      console.error('Failed to delete Cloudinary image');
    }
  }

  await Category.findByIdAndDelete(categoryId);

  return res.status(200).json({
    message: `Deleted ${category.categoryName} Successfully`,
    category,
  });
});

const createSubCategory = asyncWrapper(async (req, res) => {
    const categoryId = req.params.categoryId;

    const categoryExists = await Category.findById(categoryId);
    if (!categoryExists) {
        return res.status(404).json({message: 'Category not found'});
    }

    if(categoryExists.subCategoriesName.includes(req.body.subCategoriesName)){
        return res.status(400).json({message: 'Subcategory already exists'});
    }
    const createdSubCategory = await Category.findByIdAndUpdate(categoryId, { $push: { subCategoriesName: req.body.subCategoriesName } }, { new: true });

    return res.status(200).json({message:`Updated ${createdSubCategory.categoryName} Successfully`, category: createdSubCategory});
});

const updateSubCategory = asyncWrapper(async (req, res) => {
    const { categoryId } = req.params;
    const { oldSubCategoryName, newSubCategoryName } = req.body;

    console.log(req.body);

    const categoryExists = await Category.findById(categoryId);
    if (!categoryExists) {
        return res.status(404).json({ message: 'Category not found' });
    }

    const subCategoryIndex = categoryExists.subCategoriesName.indexOf(oldSubCategoryName);
    console.log(subCategoryIndex);
    
    if (subCategoryIndex === '-1') {
        return res.status(400).json({ message: 'Subcategory name does not match existing data' });
    }
    
    categoryExists.subCategoriesName[subCategoryIndex] = newSubCategoryName;
    const updatedCategory = await categoryExists.save()
    
    return res.status(200).json({
        message: `Subcategory updated successfully`,
        category: updatedCategory
    });
});

const deleteSubCategory = asyncWrapper(async (req, res) => {
    const categoryId = req.params.categoryId;
    const subCategoriesName = req.body.subCategoriesName;

    const categoryExists = await Category.findById(categoryId);
    if (!categoryExists) {
        return res.status(404).json({ message: 'Category not found' });
    }
    const subCategoryIndex = categoryExists.subCategoriesName.indexOf(subCategoriesName);
    if (subCategoryIndex === '-1') {
        return res.status(400).json({ message: 'Subcategory name does not match existing data' });
    }
    categoryExists.subCategoriesName.splice(subCategoryIndex, 1);
    const updatedCategory = await categoryExists.save();
    return res.status(200).json({message:`Deleted ${subCategoriesName} Successfully`, category: updatedCategory});
});

const getCategories = asyncWrapper(async (req, res) => {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;
    const { searchCategory, searchSubCategory } = req.query;

    let filter = {};

    if (searchCategory) {
        filter.categoryName = { $regex: searchCategory, $options: 'i' };
    }

    if (searchSubCategory) {
        filter.subCategoriesName = { $regex: searchSubCategory, $options: 'i' };
    }
    const categories = await Category.find(filter).skip(skip).limit(limit);
    const totalMatching = await Category.countDocuments(filter);
    if (categories.length === 0) {
        return res.status(200).json({
        message: 'No categories found',
        page,
        limit,
        matchingCount: 0,
        categories: [],
        });
    }
    return res.status(200).json({
        message: (searchCategory || searchSubCategory)
        ? 'Filtered categories fetched successfully'
        : 'Categories fetched successfully',
        page,
        limit,
        matchingCount: totalMatching,
        categories,
    });
});

export {
    createCategory,
    updateCategory,
    deleteCategory,
    createSubCategory,
    updateSubCategory,
    deleteSubCategory,
    getCategories,
};

//db.js
import mongoose from "mongoose";

const MONGO_URI = process.env.MONGO_URI;
const DATABASE = process.env.MONGO_DB;

const connectDB = async() =>{
    try {
        const connectionInstance = await mongoose.connect(`${MONGO_URI}/${DATABASE}`);

        console.log("Database Connected Successfully");
        
        // console.log(connectionInstance);
    } catch (error) {
        console.error("Error Connecting Database: ",error.message);        
    }
}

export {connectDB}


//errorHandler.midddleware.js
import ApiError from "../utils/apiError.utils.js";

const errorHandler = (err, req, res, next) => {
    // console.error('[ErrorHandler]', err);

    let statusCode = err.statusCode || 500;
    let message = err.message || 'Internal Server Error';

    // Handle Multer errors
    if (err.name === 'MulterError') {
        statusCode = 400;
        message = err.code === 'LIMIT_FILE_SIZE'
        ? 'File too large. Max allowed size is 500KB.'
        : 'File upload error';
    }

    // Handle Mongoose validation errors
    if (err.name === 'ValidationError') {
        statusCode = 400;
        message = err.message;
    }

    res.status(statusCode).json({
        success: false,
        statusCode,
        message,
        ...(process.env.NODE_ENV === 'development' && { stack: err.stack }),
    });
};

export default errorHandler;


//multer.middleware.js
import multer from 'multer';
import path from 'path';
import fs from 'fs';

if (!fs.existsSync('uploads')) {
    fs.mkdirSync('uploads');
}

const storage = multer.memoryStorage(); // Buffer used for Cloudinary

const fileFilter = (req, file, cb) => {
    const allowedTypes = /jpeg|jpg|png|gif/;
    const ext = path.extname(file.originalname).toLowerCase();
    if (allowedTypes.test(ext)) {
        cb(null, true);
    } else {
        cb(new Error('Only image files are allowed'), false);
    }
};

const upload = multer({
    storage,
    fileFilter,
    limits: { fileSize: 1 * 1024 * 1024 },
});

export const uploadCategoryImage = upload.single('categoryImage');

export const uploadProductImages = upload.fields([
    { name: 'productDisplayImage', maxCount: 1 },
    { name: 'productImages', maxCount: 50 }
]);

//category.model.js
import mongoose from "mongoose";
const categorySchema = new mongoose.Schema({
    categoryName: {
        type: String,
        required: [true,"Please Provide CategoryName"],
        min: 3,
        max: 50,
    },
    subCategoriesName:{
        type: [String],
        required:true,
        min: 3,
        max: 50,
    },
    slug: {
        type: String,
        required: [true,"Please Provide Slug"],
        min: 3,
    },
    categoryDescription: {
        type: String,
        required: [true,"Please Provide Description"],
        min: 10,
        max: 255,
    },
    categoryImage:{
        type: String,
        // required: [true,"Please Provide Category Image"],
    },
    cloudinaryId:{
        type: String,
    }
});

const Category = mongoose.model('Category', categorySchema);

export default Category;

//product.model.js
import mongoose from "mongoose";

const productSchema = new mongoose.Schema({
    productName: {
        type: String,
        required: [true,"Please Provide ProductName"],
        min: 3,
        max: 50,
    },
    categoryName:{
        type:mongoose.Schema.Types.ObjectId,
        ref: "Category",
        required: [true,"Please Provide Category Name"],
    },
    subCategoryName:{
        type:mongoose.Schema.Types.ObjectId,
        ref: "Category",
        required: [true,"Please Provide Sub-Category Name"],
    },
    productDescription: {
        type: String,
        required: [true,"Please Provide Description"],
        min: 10,
        max: 255,
    },
    productDisplayImage:{
        type: String,
        required: [true,"Please Provide Product-DisplayImage"],
    },
    productImages:{
        type: [String],
        required: [true,"Please Provide ProductImage"],
    },
    productPrice: {
        type: Number,
        min:1,
        required: [true,"Please Provide Product Price"],
    },
    productSalePrice: {
    type: Number,
    min: 1,
    required: [true, "Please Provide Product Sale Price"],
    validate: {
        validator: function (value) {
        return value < this.productPrice;
        },
        message: "Product Sale Price must be less than Product Price"
    }
    },
    stock:{
        type: Number,
        required: [true,"Please Provide Stock"],
    },
    weight:{
        type:Number,
        min: 1,
        required: [true,"Please Provide Weight"],
    },
    availability:{
        type: String,
        enum:["Ready_To_Ship","On_Booking"],
        required: [true,"Please Provide Availability"],
    },
    productType:{
        type: [String],
        enum:["Hot_product","Best_Seller","Today's_deal"],
        required: [true,"Please Provide Product Type"],
    }
});


const Product = mongoose.model('Product', productSchema);
export default Product;

//category.routes.js
import { Router } from 'express';
import {createCategory,
        createSubCategory,
        deleteCategory,
        updateCategory, 
        updateSubCategory,
        deleteSubCategory,
        getCategories} from '../controllers/category.controller.js'
import { uploadCategoryImage } from '../middlewares/multer.middleware.js';
const categoryRouter = Router();

categoryRouter.route('/category').get(getCategories);
categoryRouter.route('/createCategory').post(uploadCategoryImage,createCategory);
categoryRouter.route('/updateCategory/:categoryId').patch(uploadCategoryImage,updateCategory);
categoryRouter.route('/deleteCategory/:categoryId').delete(deleteCategory);
categoryRouter.route('/createSubCategory/:categoryId').patch(createSubCategory);
categoryRouter.route('/updateSubCategory/:categoryId').patch(updateSubCategory);
categoryRouter.route('/deleteSubCategory/:categoryId').delete(deleteSubCategory);

export default categoryRouter;

//apiError.utils.js
// utils/ApiError.js
export default class ApiError extends Error {
  constructor(statusCode, message) {
    super(message);
    this.statusCode = statusCode;
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
}

//asyncWrapper.utils.js
const asyncWrapper = (fn) => {
    return (req, res, next) => {
      fn(req, res, next).catch(next);
    };
  };
  

export default asyncWrapper


//cloudinary.utils.js
import cloudinary from '../constants/cloudinary.constant.js';
// Upload images to Cloudinary
const uploadToCloudinary = async (file) => {
    try {
        const result = await cloudinary.uploader.upload(
            `data:${file.mimetype};base64,${file.buffer.toString('base64')}`,
            {
                folder: 'product_images',
                resource_type: 'image',
            }
        );
        // console.log(result);
        return result;  
        
    } catch (err) {
        throw new Error('Cloudinary upload failed');
    }
};


export default uploadToCloudinary;

//saveLocally.utils.js
import fs from 'fs';
import path from 'path';

const saveImageLocally = (file) => {
    try {
        const uploadsDir = path.join('uploads');
        if (!fs.existsSync(uploadsDir)) fs.mkdirSync(uploadsDir);

        const uniqueFilename = `${Date.now()}_${file.originalname}`;
        const localPath = path.join(uploadsDir, uniqueFilename);

        fs.writeFileSync(localPath, file.buffer);

        return `/uploads/${uniqueFilename}`;
    } catch (err) {
        throw new Error('Failed to save image locally');
    }
};

export default saveImageLocally;

//category.validator.js
import Joi from 'joi';

const categoryValidateSchema = Joi.object({
    categoryName: Joi.string()
        .min(3)
        .max(50)
        .required()
        .messages({
        'string.empty': 'Category name is required',
        'string.min': 'Category name must be at least 3 characters',
        'string.max': 'Category name must be less than 50 characters',
        }),

    slug: Joi.string()
        .min(3)
        .required()
        .messages({
        'string.empty': 'Slug is required',
        'string.min': 'Slug must be at least 3 characters',
        }),

    categoryDescription: Joi.string()
        .min(10)
        .max(1000)
        .required()
        .messages({
        'string.empty': 'Description is required',
        'string.min': 'Description must be at least 10 characters',
        'string.max': 'Description must be less than 1000 characters',
        }),
});

export default categoryValidateSchema;


//product.validator.js
import Joi from 'joi';
import mongoose from 'mongoose';

const objectId = Joi.string().custom((value, helpers) => {
    if (!mongoose.Types.ObjectId.isValid(value)) {
        return helpers.message('Invalid ObjectId');
    }
    return value;
}, 'ObjectId Validation');

const productValidationSchema = Joi.object({
    productName: Joi.string()
    .min(3)
    .max(50)
    .required()
    .messages({
        'string.empty': 'Product name is required',
        'string.min': 'Product name should be at least 3 characters',
        'string.max': 'Product name should not exceed 50 characters',
        }),

    categoryName: objectId.required().messages({
        'any.required': 'Category is required'
    }),

    subCategoryName: objectId.required().messages({
        'any.required': 'Subcategory is required'
    }),

    productDescription: Joi.string()
        .min(10)
        .max(255)
        .required()
        .messages({
        'string.empty': 'Description is required',
        'string.min': 'Description should be at least 10 characters',
        'string.max': 'Description should not exceed 255 characters',
        }),

    productDisplayImage: Joi.string()
        .required()
        .messages({ 'any.required': 'Display image path is required' }),

    productImages: Joi.array()
        .items(Joi.string())
        .min(1)
        .required()
        .messages({ 'any.required': 'At least one product image is required' }),

    productPrice: Joi.number()
        .positive()
        .required()
        .messages({ 'number.base': 'Product price must be a number' }),

    productSalePrice: Joi.number()
        .positive()
        .required()
        .custom((value, helpers) => {
        const { productPrice } = helpers.state.ancestors[0];
        if (productPrice !== undefined && value >= productPrice) {
            return helpers.message('Sale price must be less than product price');
        }
        return value;
        }),

    stock: Joi.number()
        .integer()
        .min(0)
        .required()
        .messages({ 'number.base': 'Stock must be a number' }),

    weight: Joi.number()
        .positive()
        .required()
        .messages({ 'number.base': 'Weight must be a number' }),

    availability: Joi.string()
        .valid('Ready_To_Ship', 'On_Booking')
        .required()
        .messages({ 'any.only': 'Invalid availability option' }),

    productType: Joi.array()
        .items(Joi.string().valid('Hot_product', 'Best_Seller', "Today's_deal"))
        .min(1)
        .required()
        .messages({
        'array.includes': 'Invalid product type',
        'array.min': 'At least one product type is required'
        }),
});

export default productValidationSchema;


//.env
PORT = 3001

MONGO_URI = 'mongodb://localhost:27017'
MONGO_DB = 'Product_Store'

JWT_SECRET =

NODE_ENV =

CLOUDINARY_CLOUD_NAME = 'dl61rdb9s'
CLOUDINARY_URL = 'cloudinary://163944781922738:aIuBKaFkhdGePkx47J3pIvapzus@dl61rdb9s'
CLOUDINARY_API_KEY = '163944781922738'
CLOUDINARY_API_SECRET = 'aIuBKaFkhdGePkx47J3pIvapzus'

//app.js
import express, { urlencoded } from 'express';
import categoryRouter from './routes/category.route.js';
import ApiError from './utils/apiError.utils.js';
import errorHandler from './middlewares/errorHandler.middleware.js';

const app = express();

app.use(express.json());
app.use(urlencoded({ extended: true }));

app.use('/api/v2',categoryRouter)

// utils/ApiError.js
app.use((req, res, next) => {
    next(new ApiError(404, 'Route not found'));
});
app.use(errorHandler);

export {app}


//index.js
import { app } from "./app.js";
import dotenv from 'dotenv/config';
import { connectDB } from "./database/db.js";

connectDB()
    .then(()=>{
        app.listen(process.env.PORT,()=>{
            console.log(`Server Up and Running at port: ${process.env.PORT}`);
        })
    })
    .catch((error)=>{
        console.error("Error Connecting DB: Index.js",error);
    })


//package.json
{
  "name": "project_1",
  "version": "1.0.0",
  "description": "project_1",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "start": "nodemon index.js"
  },
  "author": "MrImaginatory",
  "license": "ISC",
  "dependencies": {
    "cloudinary": "^2.6.1",
    "dotenv": "^16.5.0",
    "express": "^5.1.0",
    "joi": "^17.13.3",
    "mongoose": "^8.14.0",
    "multer": "^1.4.5-lts.2"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}

//product.controller.js
import Category from "../models/category.model.js";
import Product from "../models/product.model.js";
import asyncWrapper from "../utils/asyncWrapper.utils.js";
import saveImageLocally from "../utils/saveLocally.utils.js";
import uploadToCloudinary from "../utils/cloudinary.utils.js"; 
import deleteFromCloudinary from "../utils/deleteCloudinary.utils.js";
import productValidationSchema from "../validators/Product.validator.js";
import ApiError from "../utils/apiError.utils.js";

const createProduct = asyncWrapper(async (req, res) => {
    const cloudinaryPublicIds = [];

    try {
        if (
            !req.files ||
            !req.files.productDisplayImage ||
            !req.files.productImages ||
            req.files.productImages.length < 1
        ) {
            throw new ApiError(400, "Please provide product display image and product images.");
        }

        if (req.files.productImages.length > 50) {
            throw new ApiError(400, "Maximum 50 product images are allowed.");
        }

        await productValidationSchema.validate(req.body, { abortEarly: false });

        const categoryExists = await Category.findById(req.body.categoryName);
        if (!categoryExists) {
            throw new ApiError(400, "Category does not exist");
        }

        let pt;
        if (req.body.productType) {
            if (typeof req.body.productType === "string") {
                pt = req.body.productType.split(",").map((item) => item.trim());
            } else if (Array.isArray(req.body.productType)) {
                pt = req.body.productType.map((item) => item.trim());
            }
        }

        const uploadFilesWithFallback = async (files) => {
            const uploadedPaths = [];

            for (const file of files) {
                try {
                    const cloudinaryResult = await uploadToCloudinary(file);
                    uploadedPaths.push(cloudinaryResult.secure_url);
                    cloudinaryPublicIds.push(cloudinaryResult.public_id);
                } catch (err) {
                    const localPath = saveImageLocally(file);
                    uploadedPaths.push(localPath);
                }
            }
            return uploadedPaths;
        };

        let displayImagePath;
        try {
            const cloudinaryDisplay = await uploadToCloudinary(req.files.productDisplayImage[0]);
            displayImagePath = cloudinaryDisplay.secure_url;
            cloudinaryPublicIds.push(cloudinaryDisplay.public_id);
        } catch (error) {
            displayImagePath = saveImageLocally(req.files.productDisplayImage[0]);
        }

        const productImagesPaths = await uploadFilesWithFallback(req.files.productImages);

        const product = new Product({
            productName: req.body.productName,
            categoryName: req.body.categoryName,
            subCategoriesName: req.body.subCategoriesName || [],
            productDisplayImage: displayImagePath,
            productImages: productImagesPaths,
            availability: req.body.availability,
            productType: pt,
            stock: req.body.stock,
            weight: req.body.weight,
            productPrice: req.body.productPrice,
            productSalePrice: req.body.productSalePrice,
            productDescription: req.body.productDescription,
        });

        await product.save();

        return res.status(201).json({
            message: "Product created successfully",
            product,
        });

    } catch (error) {
        // ðŸ§¹ Clean up uploaded cloudinary images on error
        if (cloudinaryPublicIds.length > 0) {
            const cloudinary = await import("cloudinary");
            cloudinary.v2.api.delete_resources(cloudinaryPublicIds, (err, result) => {
                if (err) console.error("Failed to delete cloudinary images:", err);
            });
        }

        console.error("Error creating product:", error);
        throw new ApiError(500, "Internal Server Error");
    }
});

const updateProduct = asyncWrapper(async (req, res) => {
    const { productId } = req.params;
    const product = await Product.findById(productId);
    if (!product) {
        throw new ApiError(404, "Product not found");
    }

    if (req.body.categoryName) {
        const categoryExists = await Category.findById(req.body.categoryName);
        if (!categoryExists) {
            throw new ApiError(400, "Category does not exist");
        }
    }

    let pt;
    if (req.body.productType) {
        if (typeof req.body.productType === "string") {
            pt = req.body.productType.split(",").map(item => item.trim());
        } else if (Array.isArray(req.body.productType)) {
            pt = req.body.productType.map(item => item.trim());
        } else {
            pt = [];
        }
    }

    const uploadFilesWithFallback = async (files) => {
        const uploadedPaths = [];
        for (const file of files) {
            try {
                const cloudinaryResult = await uploadToCloudinary(file);
                uploadedPaths.push(cloudinaryResult.secure_url);
            } catch (err) {
                const localPath = saveImageLocally(file);
                uploadedPaths.push(localPath);
            }
        }
        return uploadedPaths;
    };

    // Store old public_ids for deletion if needed
    let oldDisplayImagePublicId = null;
    let oldProductImagesPublicIds = [];

    // Extract public_id from existing product display image
    if (typeof product.productDisplayImage === 'string') {
        const match = product.productDisplayImage.match(/\/([^/]+)\.\w+$/);
        if (match) {
            oldDisplayImagePublicId = `your-folder/${match[1]}`; // Adjust folder if needed
        }
    }

    if (Array.isArray(product.productImages)) {
        oldProductImagesPublicIds = product.productImages.map((imgUrl) => {
            if (typeof imgUrl === 'string') {
                const match = imgUrl.match(/\/([^/]+)\.\w+$/);
                return match ? `your-folder/${match[1]}` : null;
            }
            return null;
        }).filter(Boolean);
    }

    let displayImagePath = product.productDisplayImage;
    let otherImagePaths = product.productImages;

    try {
        // Upload new display image if provided
        if (req.files?.productDisplayImage) {
            const cloudinaryDisplay = await uploadToCloudinary(req.files.productDisplayImage[0]);
            displayImagePath = cloudinaryDisplay.secure_url;
        }

        // Upload new product images if provided
        if (req.files?.productImages) {
            if (req.files.productImages.length < 1) {
                throw new ApiError(400, "At least one product image is required.");
            }
            if (req.files.productImages.length > 50) {
                throw new ApiError(400, "Maximum 50 product images are allowed.");
            }

            otherImagePaths = await uploadFilesWithFallback(req.files.productImages);
        }

        // Update product fields
        product.productName = req.body.productName || product.productName;
        product.categoryName = req.body.categoryName || product.categoryName;
        product.subCategoriesName = req.body.subCategoriesName || product.subCategoriesName;
        product.productDisplayImage = displayImagePath;
        product.productImages = otherImagePaths;
        product.availability = req.body.availability || product.availability;
        product.productType = pt || product.productType;
        product.stock = req.body.stock || product.stock;
        product.weight = req.body.weight || product.weight;
        product.productPrice = req.body.productPrice || product.productPrice;
        product.productSalePrice = req.body.productSalePrice || product.productSalePrice;
        product.productDescription = req.body.productDescription || product.productDescription;

        const updatedProduct = await product.save();

        // If update was successful, delete old images
        if (displayImagePath !== product.productDisplayImage && oldDisplayImagePublicId) {
            await deleteFromCloudinary(oldDisplayImagePublicId);
        }

        if (
            otherImagePaths !== product.productImages &&
            oldProductImagesPublicIds.length > 0
        ) {
            for (const publicId of oldProductImagesPublicIds) {
                await deleteFromCloudinary(publicId);
            }
        }

        return res.status(200).json({
            message: "Product updated successfully",
            product: updatedProduct,
        });

    } catch (error) {
        // Cleanup newly uploaded Cloudinary images if update fails
        if (displayImagePath && displayImagePath.includes('res.cloudinary.com')) {
            const match = displayImagePath.match(/\/([^/]+)\.\w+$/);
            if (match) {
                await deleteFromCloudinary(`your-folder/${match[1]}`);
            }
        }

        if (Array.isArray(otherImagePaths)) {
            for (const url of otherImagePaths) {
                if (typeof url === 'string' && url.includes('res.cloudinary.com')) {
                    const match = url.match(/\/([^/]+)\.\w+$/);
                    if (match) {
                        await deleteFromCloudinary(`your-folder/${match[1]}`);
                    }
                }
            }
        }

        console.error("Error updating product:", error);
        throw new ApiError(500, "Internal Server Error");
    }
});

const deleteProduct = asyncWrapper(async (req, res) => {
    const { productId } = req.params;
    const product = await Product.findById(productId);
    if (!product) {
        throw new ApiError(404, "Product not found");
    }
    const deleteProducts = await Product.findByIdAndDelete({ _id: productId });

    return res.status(200).json({
        message: "Product deleted successfully",
        product: deleteProducts,
    });
})

const getAllProducts = asyncWrapper(async (req, res) => {
    const page = parseInt(req.query.page, 10) || 1;
    const limit = parseInt(req.query.limit, 10) || 10;
    const skip = (page - 1) * limit;

    const {searchProduct} = req.query;

    let filter ={};

    if(searchProduct){
        filter = {productName: { $regex: searchProduct, $options: 'i' } }
    }

    const products = await Product.find(filter)
        .skip(skip)
        .limit(limit)
        .sort({ createdAt: -1 });
    
    return res.status(200).json({
        message: "Products fetched successfully",
        totalProducts: await Product.countDocuments(),
        page,
        limit,
        products,
    });

})

export { createProduct, updateProduct,deleteProduct,getAllProducts };

//product.route.js
import { Router } from "express";
import { createProduct,updateProduct,deleteProduct, getAllProducts } from "../controllers/product.controller.js";
import { uploadProductImages } from "../middlewares/multer.middleware.js";

const productRouter = Router();

productRouter.route('/createProduct').post(uploadProductImages,createProduct);
productRouter.route('/updateProduct/:productId').patch(uploadProductImages,updateProduct);
productRouter.route('/deleteProduct/:productId').delete(deleteProduct);
productRouter.route('/getProducts').get(getAllProducts);

export default productRouter;